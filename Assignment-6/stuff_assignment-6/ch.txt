
	la $a0, arr
    lw $t0, array_size
	lw $t5, on

    # initialize the min value in the array
    lwc1 $f0, minval
    lw $s0, 0($a0)
    lwc1 $f2, 0($a0)
    addi $a0, $a0, 4

    # find the minimum value in the array
    loop_min:
        ble $t0, $zero, init_min
		sub $t0, $t0, $t5
        lw $s0, 0($a0)
        addi $a0, $a0, 4
        lwc1 $f4, 0($a0)
        c.lt.s $f4, $f2
        bc1t update_min
        j loop_min
    update_min:
        mov.s $f2, $f4
        j loop_min
		
		
	la $a0, arr
    lw $t0, array_size
	
		
	# initialize the max value in the array
    lwc1 $f0, maxval
    lw $s0, 0($a0)
    lwc1 $f4, 0($a0)
    addi $a0, $a0, 4

    # find the maximum value in the array
    loop_max:
        ble $t0, $zero, init_max
		sub $t0, $t0, $t5
        lw $s0, 0($a0)
        addi $a0, $a0, 4
        lwc1 $f6, 0($a0)
        c.lt.s $f4, $f6
        bc1t update_max
        j loop_max
    update_max:
        mov.s $f4, $f6
        j loop_max
		
		
	calc:
		lwc1 $f8, n 
		li.s $f6, 1.0
		sub.s $f4, $f2, $f0
		add.s $f4, $f4, $f6 
		div.s $f4, $f4, $f8
		cvt.w.s $f4, $f4		
		mfc1 $t0, $f0
	
	#calc1:
	#	li 
	init_min:
	
	
	init_max:

















# Input: $a0 = pointer to array, $a1 = length of array
# Output: sorted array in memory
.data
arr: .float 0.897, 0.565, 0.656, 0.1234, 0.665, 0.3434, 0.1126, 0.554, 0.3349, 0.678
F_SIZE: .word 4        # size of floating point number in bytes
NUM_BUCKETS: .word 5  # number of buckets to use
MAX_FLOAT: .float 1.0   # maximum value of floating point number

# Allocate memory for buckets
.text
main:
lw $t0, F_SIZE
lw $t1, NUM_BUCKETS
mul $t6, $t0, $t1
sub $sp, $sp, $t6
move $t0, $sp

# Determine size of each bucket
li.s $f0, MAX_FLOAT
divu $t1, $t1, NUM_BUCKETS

# Partition input elements into buckets
li $t2, 0 # loop counter for input elements
partition_loop:
  beq $t2, $a1, sort_buckets # end loop if all input elements are processed
  
  lw $t3, ($a0) # load floating point number
  divu $t4, $t3, $t1 # determine bucket number
  add $t4, $t4, $t0 # add offset to bucket pointer
  sw $t3, ($t4) # store element in bucket
  addi $a0, $a0, F_SIZE # advance pointer to next element
  addi $t2, $t2, 1 # increment loop counter
  j partition_loop

# Sort each bucket using insertion sort
sort_buckets:
  move $t4, $t0 # set $t4 to first bucket pointer
  li $t5, 0 # loop counter for buckets
bucket_loop:
  beq $t5, NUM_BUCKETS, concat_buckets # end loop if all buckets are processed
  move $a0, $t4 # set pointer to start of bucket
  addi $a1, $t1, 1 # set length of bucket
  jal insertion_sort # sort the bucket using insertion sort
  addi $t4, $t4, F_SIZE # advance pointer to next bucket
  addi $t5, $t5, 1 # increment loop counter
  j bucket_loop

# Concatenate sorted buckets
concat_buckets:
  move $t4, $t0 # set $t4 to first bucket pointer
  li $t5, 0 # loop counter for buckets
  move $a0, $sp # set pointer to start of output array
concat_loop:
  beq $t5, NUM_BUCKETS, end_sort # end loop if all buckets are processed
  move $a1, $t1 # set length of bucket
  jal memcpy # copy the bucket to the output array
  addi $t4, $t4, F_SIZE # advance pointer to next bucket
  addi $t5, $t5, 1 # increment loop counter
  addi $a0, $a0, $t1 # advance pointer to end of copied bucket
  j concat_loop

# End of sort
end_sort:
  addi $sp, $sp, NUM_BUCKETS*F_SIZE # deallocate memory for buckets
  jr $ra # return from function


# Insertion sort algorithm for MIPS
# Input: $a0 = pointer











